package ninja.javahacker.jaspasema;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.function.Function;
import lombok.NonNull;
import ninja.javahacker.jaspasema.exceptions.badmapping.BadServiceMappingException;
import ninja.javahacker.jaspasema.exceptions.paramvalue.AbsentRequiredParameterException;
import ninja.javahacker.jaspasema.exceptions.paramvalue.MalformedJsonBodyException;
import ninja.javahacker.jaspasema.ext.ObjectUtils;
import ninja.javahacker.jaspasema.processor.AnnotatedParameter;
import ninja.javahacker.jaspasema.processor.JsonTypesProcessor;
import ninja.javahacker.jaspasema.processor.ParamProcessor;
import ninja.javahacker.jaspasema.processor.ParamSource;

/**
 * Defines that a method parameter corresponds to a property from the body of a request in JSON format.
 * @author Victor Williams Stafusa da Silva
 */
@ParamSource(processor = JsonBodyProperty.Processor.class)
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface JsonBodyProperty {
    public boolean required() default false;

    /**
     * Defines if the JSON should be read in lenient mode or not.
     * In lenient mode, unknown properties in the JSON are simply ignored. In strict mode, their presence triggers an error.
     * <p>The default value is {@code false}. I.e. to NOT be lenient.</p>
     * @return If the JSON should be read in lenient mode or not.
     */
    public boolean lenient() default false;

    /**
     * Defines the name of the variable used to hold the value of this parameter in the autogenerated javascript stub.
     * If unspecified, this defaults to the parameter name.
     * @return The name of the variable used to hold the value of this parameter in the autogenerated javascript stub.
     */
    public String jsVar() default "";

    /**
     * The class that is responsible for processing the {@link JsonBodyProperty} annotation.
     */
    public static class Processor implements ParamProcessor<JsonBodyProperty> {

        private static final String INSTRUCTION_TEMPLATE = "__data.#VAR# = #VAR#;";

        private static final String REQUEST_TYPE = "__requestType = 'application/json; charset=utf-8';";

        private static final String JSONIFY = "__data = JSON.stringify(__data);";

        /**
         * Sole constructor.
         */
        public Processor() {
        }

        /**
         * {@inheritDoc}
         * @param <E> {@inheritDoc}
         * @param param {@inheritDoc}
         * @return {@inheritDoc}
         * @throws BadServiceMappingException {@inheritDoc}
         */
        @NonNull
        @Override
        public <E> Stub<E> prepare(@NonNull AnnotatedParameter<JsonBodyProperty, E> param) throws BadServiceMappingException {
            var annotation = param.getAnnotation();
            var p = param.getParameter();
            Function<Throwable, MalformedJsonBodyException> thrower = e -> new MalformedJsonBodyException(p, e);
            var js = ObjectUtils.choose(annotation.jsVar(), param.getParameterName());
            ParamProcessor.Worker<E> w = ctx -> {
                var map = JsonTypesProcessor.readJsonMap(ctx.body(), thrower);
                var obj = map.get(js);
                if (obj != null) return JsonTypesProcessor.convert(annotation.lenient(), obj, param.getTarget());
                if (annotation.required()) throw new AbsentRequiredParameterException(p);
                return null;
            };
            return new Stub<>(w, js, INSTRUCTION_TEMPLATE.replace("#VAR#", js), REQUEST_TYPE, JSONIFY);
        }
    }
}