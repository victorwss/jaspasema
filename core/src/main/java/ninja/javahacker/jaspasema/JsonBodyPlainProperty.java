package ninja.javahacker.jaspasema;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Year;
import java.time.YearMonth;
import java.util.Map;
import java.util.function.Function;
import lombok.NonNull;
import ninja.javahacker.jaspasema.exceptions.badmapping.BadServiceMappingException;
import ninja.javahacker.jaspasema.exceptions.paramvalue.AbsentRequiredParameterException;
import ninja.javahacker.jaspasema.exceptions.paramvalue.MalformedJsonBodyException;
import ninja.javahacker.jaspasema.ext.ObjectUtils;
import ninja.javahacker.jaspasema.format.ParameterParser;
import ninja.javahacker.jaspasema.processor.AnnotatedParameter;
import ninja.javahacker.jaspasema.processor.JsonTypesProcessor;
import ninja.javahacker.jaspasema.processor.ParamProcessor;
import ninja.javahacker.jaspasema.processor.ParamSource;

/**
 * Defines that a method parameter corresponds to the body of a request in plain text format.
 * @author Victor Williams Stafusa da Silva
 */
@ParamSource(processor = JsonBodyPlainProperty.Processor.class)
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface JsonBodyPlainProperty {

    /**
     * Tells if the value of this property is required to be present in the JSON body or not.
     * <p>If this property is set to {@code true} and the property value is absent,
     * an {@code AbsentRequiredParameterException} will be thrown.</p>
     * <p>If this property is set to {@code false} and the property value is absent, it will be setted to {@code null} if
     * it is an object type, {@code false} if it is {@code boolean} or zero if it is of some other primitive type.</p>
     * @return If the value of this property is required to be present in the JSON body or not.
     */
    public boolean required() default false;

    /**
     * This tells which is the desired date format for converting the value of the body property to an instance of {@link LocalDate}
     * {@link LocalDateTime}, {@link LocalTime}, {@link Year} or {@link YearMonth}.
     * <p>Example of valid formats includes {@code "dd-MM-uuuu"}, {@code "dd/MM/uuuu HH:mm:ss"}, {@code "MM/uuuu"} among others.</p>
     * <p>This field is mandatory if the parameter type is one of the aforemetioned formats. Otherwise, this field should not be used.</p>
     * @see <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html#patterns">Patterns</a>
     * @return The desired date format.
     */
    public String dateFormat() default "";

    /**
     * Defines the name of the variable used to hold the value of this parameter in the autogenerated javascript stub.
     * If unspecified, this defaults to the parameter name.
     * @return The name of the variable used to hold the value of this parameter in the autogenerated javascript stub.
     */
    public String jsVar() default "";

    /**
     * The class that is responsible for processing the {@link JsonBodyPlainProperty} annotation.
     */
    public static class Processor implements ParamProcessor<JsonBodyPlainProperty> {

        private static final String INSTRUCTION_TEMPLATE = "__data.#VAR# = #VAR#;";

        private static final String REQUEST_TYPE = "__requestType = 'application/json; charset=utf-8';";

        private static final String JSONIFY = "__data = JSON.stringify(__data);";

        private static final Map<Class<?>, Object> ZEROS = Map.ofEntries(
                Map.entry(boolean.class, Boolean.FALSE),
                Map.entry(int.class, 0),
                Map.entry(short.class, (short) 0),
                Map.entry(byte.class, (byte) 0),
                Map.entry(long.class, 0L),
                Map.entry(float.class, 0.0f),
                Map.entry(double.class, 0.0),
                Map.entry(char.class, '\0')
        );

        /**
         * Sole constructor.
         */
        public Processor() {
        }

        /**
         * {@inheritDoc}
         * @param <E> {@inheritDoc}
         * @param param {@inheritDoc}
         * @return {@inheritDoc}
         * @throws BadServiceMappingException {@inheritDoc}
         */
        @NonNull
        @Override
        @SuppressWarnings("unchecked")
        public <E> Stub<E> prepare(@NonNull AnnotatedParameter<JsonBodyPlainProperty, E> param) throws BadServiceMappingException {
            var annotation = param.getAnnotation();
            var p = param.getParameter();
            Function<Throwable, MalformedJsonBodyException> thrower = e -> new MalformedJsonBodyException(p, e);
            var js = ObjectUtils.choose(annotation.jsVar(), param.getParameterName());
            var part = ParameterParser.prepare(param, annotation.dateFormat());
            ParamProcessor.Worker<E> w = ctx -> {
                var map = JsonTypesProcessor.readJsonMap(ctx.body(), thrower);
                var obj = map.get(js);
                if (obj != null) return part.make(obj.toString());
                if (annotation.required()) throw new AbsentRequiredParameterException(p);
                return (E) ZEROS.get(p.getType());
            };
            return new Stub<>(w, js, INSTRUCTION_TEMPLATE.replace("#VAR#", js), REQUEST_TYPE, JSONIFY);
        }
    }
}